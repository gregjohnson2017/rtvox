#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D img;

layout(set = 0, binding = 1) uniform CameraInfo {
    vec3 eye;
    float fov;
    vec3 target;
} uniforms;

// layout(set = 0, binding = 2, rgba8) uniform imageCubeArray cubeMapArray;

vec3 calculate_ray() {
    float x = float(gl_GlobalInvocationID.x);
    float y = float(gl_GlobalInvocationID.y);
    float k = float(gl_NumWorkGroups.x * gl_WorkGroupSize.x);
    float m = float(gl_NumWorkGroups.y * gl_WorkGroupSize.y);
    vec3 E = uniforms.eye;
    vec3 T = uniforms.target;
    vec3 v = vec3(0.0, 1.0, 0.0);
    float theta = uniforms.fov;

    vec3 t = T - E;
    vec3 t_n = normalize(t);
    vec3 b = cross(t, v);
    vec3 b_n = normalize(b);
    vec3 v_n = cross(t_n, b_n);

    float g_x = tan(theta / 2.0);
    float g_y = g_x * (m - 1.0) / (k - 1.0);

    vec3 q_x = 2.0 * g_x * b_n / (k - 1.0);
    vec3 q_y = 2.0 * g_y * v_n / (m - 1.0);
    vec3 p_1m = t_n - g_x * b_n - g_y * v_n;

    vec3 p_ij = p_1m + q_x * (x - 1.0) + q_y * (y - 1.0);
    vec3 ray = normalize(p_ij);

    return ray;
}

#define NUMDIM 3
#define YZ 0
#define XZ 1
#define XY 2

vec3 hit_aabb(vec3 ray) {
    vec3 miss_col = vec3(0.0, 0.0, 0.0);
    vec3 center = vec3(0.0, 0.0, -5.0);
    vec3 minB = vec3(-0.5, -0.5, -5.5);
    vec3 maxB = vec3(0.5, 0.5, -4.5);
    vec3 origin = uniforms.eye;
    vec3 dir = ray;
    vec3 coord = vec3(0.0, 0.0, 0.0);

	bool inside = true;
	ivec3 quadrant = ivec3(0, 0, 0);
	int whichPlane = 0;
	vec3 maxT = vec3(0.0, 0.0, 0.0);
    vec3 candidatePlane = vec3(0.0, 0.0, 0.0);

	/* Find candidate planes; this loop can be avoided if
   	rays cast all from the eye(assume perpsective view) */
	for (int i = 0; i < NUMDIM; i++) {
		if (origin[i] < minB[i]) {
			quadrant[i] = XZ;
			candidatePlane[i] = minB[i];
			inside = false;
		} else if (origin[i] > maxB[i]) {
			quadrant[i] = YZ;
			candidatePlane[i] = maxB[i];
			inside = false;
		} else {
			quadrant[i] = XY;
		}
    }
	/* Ray origin inside bounding box */
	if (inside)	{
		coord = origin;
		return vec3(1.0, 1.0, 1.0);
	}
	/* Calculate T distances to candidate planes */
	for (int i = 0; i < NUMDIM; i++) {
		if (quadrant[i] != XY && dir[i] != 0.) {
			maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];
        } else {
			maxT[i] = -1.;
        }
    }
	/* Get largest of the maxT's for final choice of intersection */
	for (int i = 1; i < NUMDIM; i++) {
		if (maxT[whichPlane] < maxT[i]) {
			whichPlane = i;
        }
    }
	/* Check final candidate actually inside box */
	if (maxT[whichPlane] < 0.) {
        return miss_col;
    }
	for (int i = 0; i < NUMDIM; i++) {
		if (whichPlane != i) {
			coord[i] = origin[i] + maxT[whichPlane] *dir[i];
			if (coord[i] < minB[i] || coord[i] > maxB[i]) {
				return miss_col;
            }
		} else {
			coord[i] = candidatePlane[i];
		}
    }

    // demonstration of hit coord
    if (coord[0] > 0 && coord[1] > 0 && coord[2] > -5) {
        return vec3(0.2, 0.2, 0.2);
    }
    // int block_type = 4;
    // return imageLoad(cubeMapArray, ivec3(0,0,block_type)).xyz;
    if (whichPlane == XZ) {
        if (coord[1] > minB.y) {
            // top
            return vec3(1.0, 0.0, 0.0);
        } else {
            // bottom
            return vec3(1.0, 1.0, 0.0);
        }
    } else if (whichPlane == YZ) {
        if (coord[0] > minB.x) {
            // right
            return vec3(0.0, 1.0, 1.0);
        } else {
            // left
            return vec3(0.0, 1.0, 0.0);
        }
    } else {
        if (coord[2] > minB.z) {
            // back
            return vec3(1.0, 0.0, 1.0);
        } else {
            // front
            return vec3(0.0, 0.0, 1.0);
        }
    }
}

void main() {
    float x = float(gl_GlobalInvocationID.x);
    float y = float(gl_GlobalInvocationID.y);

    vec3 ray = calculate_ray();
    vec3 col = hit_aabb(ray);
    imageStore(img, ivec2(x, y), vec4(col, 0));
}
